---
layout: post
title: Enum Parse Extension Methods
date: '2008-11-04 15:00:00'
---

<p>When I write code I don't like to depend on catching exceptions to control my programming logic, so as much as I can I try to check for nulls, empty, etc...</p><p>When parsing one type into another there are usually TryParse() methods available so that an exception does not occur. I've always been a little confused why there wasn't such a method off the Enum class. So, I decided to make my own.</p><p>However, after I started to extend the TryParse method off of the Enum, the answer started to become clear why that was not a feature :) I could extend the actual specific enum, but that didn't really help me any. I wanted a Generic solution for all enums.</p><p>So, instead of making an Enum.TryParse(), I decided to extend the string class to add string.ToEnum() and string.TryToEnum(). The string is usually the class that I want to parse into a specific Enum after all.</p><p>The following is the Extension methods that I created...</p><pre><br>using System;<br><br>namespace Web.Helpers {<br>    public static class EnumHelper {<br>        public static bool TryToEnum<T>(this string obj, out T parsed) {<br>            bool isParsed = false;<br><br>            if (Enum.IsDefined(typeof(T), obj)) {<br>                parsed = (T)Enum.Parse(typeof(T), obj);<br>                isParsed = true;<br>            } else {<br>                parsed = (T)Enum.Parse(typeof(T), Enum.GetNames(typeof(T))[0]);<br>            }<br><br>            return isParsed;<br>        }<br><br>        public static T ToEnum<T>(this string obj) {<br>            return (T)Enum.Parse(typeof(T), obj);<br>        }<br>    }<br>}<br></pre><p>I created a set of 4 MS Unit tests to exercise different scenarios that might exist. Let me know if you see any other tests that I should test.</p><pre><br>using System;<br>using Microsoft.VisualStudio.TestTools.UnitTesting;<br>using Web.Helpers;<br><br>namespace WebTests.Generic {<br>    [TestClass]<br>    public class EnumTest {<br>        public enum Color { Red, Orange, Yellow, Green, Blue, Indigo, Violet };<br><br>        [TestMethod]<br>        public void TryToEnumWorksWithValidEnum() {<br>            Color parsedColor = Color.Blue;<br><br>            string realColor = "Yellow";<br>            bool canParse = realColor.TryToEnum<Color>(out parsedColor);<br>            Assert.AreEqual(true, canParse);          <br>        }<br><br>        [TestMethod]<br>        public void TryToEnumWorksWithInvalidEnum() {<br>            Color parsedColor = Color.Blue;<br><br>            string fakeColor = "Elijahish";<br>            bool canParse = fakeColor.TryToEnum<Color>(out parsedColor);<br>            Assert.AreEqual(false, canParse);<br>        }<br><br>        [TestMethod]<br>        public void ToEnumWorksWithValidEnum() {<br>            Color parsedColor = Color.Blue;<br><br>            string realColor = "Yellow";<br>            parsedColor = realColor.ToEnum<Color>();<br>            Assert.AreEqual(Color.Yellow, parsedColor);<br>        }<br><br>        [TestMethod, ExpectedException(typeof(ArgumentException), "Unable to parse enum")]<br>        public void ToEnumThrowsExceptionWithInalidEnum() {<br>            Color parsedColor = Color.Blue;<br><br>            string fakeColor = "Elijahish";<br>            parsedColor = fakeColor.ToEnum<Color>(); <br>        }<br>    }<br>}<br></pre><p>Have you found yourself doing some sort of the same thing? If so, how?</p>