---
layout: post
title: ASP.NET MVC Html.RadioButtonList Blues
date: '2009-03-25 05:08:00'
---

<p>Recently I upgraded our ASP.NET MVC project from Preview 5 to RC2. At first I thought the Html.RadioButtonList extension was removed completely, but then realized that it was no longer in the main MVC assembly, but was moved to the Futures project (although I don't know why).</p> <p>The Preview 5 version of the Html.RadioButtonList rendered the following output...</p> <div><a href="http://4.bp.blogspot.com/_L6DiZQsfJzs/Scmp4rZiIYI/AAAAAAAAGvA/OK1SegpLy1E/s1600-h/RadioButtonListPreview5.PNG" imageanchor="1"><img border="0" src="http://4.bp.blogspot.com/_L6DiZQsfJzs/Scmp4rZiIYI/AAAAAAAAGvA/OK1SegpLy1E/s400/RadioButtonListPreview5.PNG"></a></div> <p>However, once I got my code to compile I went to run my application only to find that it rendered two RadioButtons with no labels! Where did the labels go?</p> <div><a href="http://2.bp.blogspot.com/_L6DiZQsfJzs/Scmp-rtA_8I/AAAAAAAAGvI/Ni3uATg50qk/s1600-h/RadioButtonLisRtm.PNG" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/_L6DiZQsfJzs/Scmp-rtA_8I/AAAAAAAAGvI/Ni3uATg50qk/s400/RadioButtonLisRtm.PNG"></a></div>  <p>I pulled down the source code for the 1.0 release (just to make sure it wasn't fixed in the RTM as opposed to the RC2) and dove into the extension code. Nowhere did I see the labels being applied in the extension.</p> <pre><br>//C:\...\MVC-RTM\MVC\src\MvcFutures\Mvc\RadioExtensions.cs<br>private static string[] RadioButtonListInternal(this HtmlHelper htmlHelper, string name, IEnumerable<SelectListItem> selectList, bool usedViewData, IDictionary<string, object> htmlAttributes) {<br>   if (String.IsNullOrEmpty(name)) {<br>      throw new ArgumentException(MvcResources.Common_NullOrEmpty, "name");<br>   }<br>   if (selectList == null) {<br>      throw new ArgumentNullException("selectList");<br>   }<br><br>   // If we haven't already used ViewData to get the entire list of items then we need to<br>   // use the ViewData-supplied value before using the parameter-supplied value.<br>   if (!usedViewData) {<br>      object defaultValue = htmlHelper.ViewData.Eval(name);<br><br>      if (defaultValue != null) {<br>         IEnumerable defaultValues = new[] { defaultValue };<br>         IEnumerable<string> values = from object value in defaultValues select Convert.ToString(value, CultureInfo.CurrentCulture);<br>         HashSet<string> selectedValues = new HashSet<string>(values, StringComparer.OrdinalIgnoreCase);<br>         List<SelectListItem> newSelectList = new List<SelectListItem>();<br><br>         foreach (SelectListItem item in selectList) {<br>            item.Selected = (item.Value != null) ? selectedValues.Contains(item.Value) : selectedValues.Contains(item.Text);<br>            newSelectList.Add(item);<br>         }<br><br>         selectList = newSelectList;<br>      }<br>   }<br><br>   IEnumerable<string> radioButtons = selectList.Select<SelectListItem, string>(item => htmlHelper.RadioButton(name, item.Value, item.Selected, htmlAttributes));<br><br>   return radioButtons.ToArray();<br>}<br></pre> <p>Next I looked at the Unit Tests for the extesion. I was please to see tests for the RadioButtonList, but was shocked to see that the asserts were verifying html that didn't have any labels applied!</p> <pre><br>//C:\...\MVC-RTM\MVC\test\MvcFuturesTest\Mvc\Test\RadioExtensionsTest.cs<br>[TestMethod]<br>public void RadioButtonListItemSelected() {<br>   // Arrange<br>   HtmlHelper htmlHelper = TestHelper.GetHtmlHelper(new ViewDataDictionary());<br><br>   // Act<br>   string[] html = htmlHelper.RadioButtonList("FooList", GetRadioButtonListData(true));<br><br>   // Assert<br>   Assert.AreEqual(@"<input id=""FooList"" name=""FooList"" type=""radio"" value=""foo"" />", html[0]);<br>   Assert.AreEqual(@"<input id=""FooList"" name=""FooList"" type=""radio"" value=""bar"" />", html[1]);<br>   Assert.AreEqual(@"<input checked=""checked"" id=""FooList"" name=""FooList"" type=""radio"" value=""baz"" />", html[2]);<br>}<br><br>private static SelectList GetRadioButtonListData(bool selectBaz) {<br>   List<RadioItem> list = new List<RadioItem>();<br>   list.Add(new RadioItem { Text = "text-foo", Value = "foo" });<br>   list.Add(new RadioItem { Text = "text-bar", Value = "bar" });<br>   list.Add(new RadioItem { Text = "text-baz", Value = "baz" });<br>   return new SelectList(list, "value", "TEXT", selectBaz ? "baz" : "something-else");<br>}<br><br>private class RadioItem {<br>   public string Text {<br>      get;<br>      set;<br>   }<br><br>   public string Value {<br>      get;<br>      set;<br>   }<br>}  <br></pre> <p>Where does that leave us? I guess using the Futures Html.RadioButtonList isn't all that helpful after all. So, instead I decided to loop through my DataSource and create individual Html.RadioButton and Label combinations.</p> <pre><br><!-- After using and looking at the code for the Html.RadioButtonList in the ASP.NET MVC 1.0 RTM codebase, I'm not sure how it is supposed to be useful. It only outputs the actual input radio button and doesn't render any corresponding labels. To get around this I ended up writing a foreach creating individual Html.RadioButton and labels --><br><% <br>var radioButtonList = new SelectList(new List<ListItem> {<br>   new ListItem { Text = "Current", Value="false", Selected=true }, <br>   new ListItem { Text = "Other", Value="true"}}, "Value", "Text", "false");<br>var htmlAttributes = new Dictionary<string, object> { <br>   { "class", "radioButtonList" },<br>   { "onclick", "if(eval(this.value)) { $('#tblDate').show('slow'); } else { $('#tblDate').hide('slow'); }" }<br>};<br>foreach (var radiobutton in radioButtonList) { %><br>   <%=Html.RadioButton("rblDate", radiobutton.Value, radiobutton.Selected, htmlAttributes)%><br>   <label><%=radiobutton.Text%></label><br><% } %>   <br></pre>