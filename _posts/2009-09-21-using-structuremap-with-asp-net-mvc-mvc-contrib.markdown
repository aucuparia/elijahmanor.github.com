---
layout: post
title: Using StructureMap with ASP.NET MVC &amp; MVC Contrib
date: '2009-09-21 02:54:00'
---

<p>I’ve found myself using the <a href="http://www.codeplex.com/MVCContrib" target="_blank">MVC Contrib</a> project more and more lately. There are tons of golden framework nuggets just waiting to be used.</p>  <p>I recently integrated <a href="http://structuremap.sourceforge.net/Default.htm" target="_blank">StructureMap</a> into the my current ASP.NET MVC framework using MVC Contrib. The reason I decided to write this post is because most of the resources I found on the internet appeared to be a little out of date and used deprecated StructureMap APIs. So, here it goes…</p>  <blockquote>   <p>Note: The following examples are using <a href="http://sourceforge.net/projects/structuremap/files/" target="_blank">StructureMap v2.5.3</a> & <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=d34f9eaa-fcbe-4e20-b2fd-a9a03de7d6dd&displaylang=en" target="_blank">ASP.NET MVC v2 Preview 1</a> & <a href="http://github.com/mvccontrib/MvcContrib/tree/mvc2" target="_blank">MVC Contrib MVC2 Branch</a> code bits. You may find minor differences in API &| syntax if you are using a different version.</p> </blockquote>  <p>First lets investigate why StructureMap is necessary in the first place. You can find some good blog posts by <a href="http://twitter.com/JeremyDMiller" target="_blank">Jeremy D. Miller</a> about the basics of the Dependency Injection Pattern and using an IOC tool.</p>  <ul><li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2005/10/06/132825.aspx" target="_blank">The Dependency Injection Pattern – What is it and why do I care?</a> </li>    <li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2008/06/29/some-concepts-to-know-first.aspx" target="_blank">Before you use an IoC tool, some concepts to know first</a> </li> </ul><p>In order to facilitate mocking and decouple our application we pass an interface of our service into our controller instead of a concrete class. The default controller factory that ASP.NET MVC uses requires a default constructor to be present, but we are going to define our own Controller Factory later in this post using one of the MVC Contrib classes. </p>  <blockquote>   <p>Note: There is actually a really good <a href="http://blog.wekeroad.com/mvc-storefront/mvcstore-part-13/" target="_blank">screencast</a> with <em>@</em><a href="http://hootsuite.com/dashboard#">robconery</a> and <em>@</em><a href="http://hootsuite.com/dashboard#">jeremydmiller</a> about using StructureMap in ASP.NET MVC. There were several “Aha!” moments for me as I watched it. The StructureMap API has changed slightly since the <a href="http://blog.wekeroad.com/mvc-storefront/mvcstore-part-13/" target="_blank">screencast</a>, but I will show the updated syntax in the following of this post.</p> </blockquote>  <p>The following is a typical ContactController class that will house the Index, Details, Create, Edit, and Delete actions. You will notice that instead of having a default constructor, I have an overloaded contructor and am passing in an interface to my service. I will wire up StructureMap to handle passing in the appropriate object later in this post.</p>  <pre>public partial class ContactController : Controller<br>{<br>    private IContactService service;<br><br>    public ContactController(IContactService service)<br>    {<br>        this.service = service;<br>    }<br>}    </pre> <p>The wiring part, happens typically in the Application_Start event from the Global.asax.cs file. In addition to Registering your MVC routes (which should have already been wired up when you created your MVC application) you need to both configure StuctureMap to know what concrete classes map to what interfaces as well as tell MVC to use StructureMap to create its controllers.</p> <pre>public class Global : HttpApplication<br>{<br>    protected void Application_Start(object sender, EventArgs e)<br>    {<br>        RegisterRoutes(RouteTable.Routes);<br><br>        Bootstrapper.ConfigureStructureMap();<br>        ControllerBuilder.Current.SetControllerFactory(new StructureMapControllerFactory());<br>    }<br>}</pre> <p>I am going to attempt and explain the above code snippet line by line, so lets start with the Bootstrapper.ConfigureStructureMap() and then we will discuss the StructureMapControllerFactory().</p> <p>After everything is said and done, the important part of StructureMap is that it knows what interfaces should map to what concrete types so that it can inject the appropriate instances at runtime. This is where the Bootstrapper.ConfigureStructureMap() comes into play.</p> <pre>public static class Bootstrapper <br>{<br>    public static void ConfigureStructureMap()<br>    {<br>        ObjectFactory.Initialize(x => x.AddRegistry(new MyApplicationRegistry()));            <br>    }<br>}<br><br>public class MyApplicationRegistry : Registry<br>{<br>    public MyApplicationRegistry()<br>    {<br>        Scan(assemblyScanner =><br>        {<br>            assemblyScanner.TheCallingAssembly();<br>            assemblyScanner.WithDefaultConventions();<br>        });<br>    }<br>}</pre> <p>The above code is initializing StructureMap with the MyApplicationRegistry that contains the rules for the interface & concrete type mappings. You may be wondering, “But I don’t see where IContactService is mapped to ContactService” and that is a very good question. The answer is that StuctureMap takes the <a href="http://en.wikipedia.org/wiki/Convention_over_Configuration" target="_blank">Convention Over Configuration</a> approach and tries to take some educational guesses based on a set of <a href="http://structuremap.sourceforge.net/ScanningAssemblies.htm#section8" target="_blank">default naming conventions</a>.</p> <p>Lets say that your configuration isn’t following standard naming conventions. Can you still use StructureMap? Well, of course you can :) You have full control over the mappings and can set them up however you wish. The following is an example of me manually doing the mapping instead of using the <a href="http://structuremap.sourceforge.net/ScanningAssemblies.htm#section8" target="_blank">default naming conventions</a>. The Bootstrapper remains the same, so I only will show the code that is different below…</p> <pre>public class MyApplicationRegistry : Registry<br>{<br>    public MyApplicationRegistry()<br>    {<br>        ForRequestedType<IContactService>().TheDefaultIsConcreteType<ContactService>();<br>        ForRequestedType<IValidationRunner>().TheDefaultIsConcreteType<ValidationRunner>();<br>    }<br>}</pre> <p>Now lets focus on the StructureMapControllerFactory that we saw after we Configured StructureMap from the Global.asax. The StructureMapControllerFactory class that I am instantiating actually comes with the MVC Contrib project.  The contents of this class isn’t really all that complicated, but its one less thing you have to write by hand. The following is an example of a oversimplified implementation of the StructureMapControllerFactory that you could write yourself…</p> <pre>public class StructureMapControllerFactory : DefaultControllerFactory<br>{<br>    protected override IController GetControllerInstance(RequestContext requestContext, Type controllerType)<br>    {<br>        return ObjectFactory.GetInstance(controllerType) as IController;<br>    }<br>}</pre> <p>Since we separated our dependencies and used StructureMap for injection our application is now loosely coupled and our ability to Unit Test more areas has increased. </p> <p>Stay tuned for a new series where I will upgrade a standard ASP.NET MVC project to ASP.NET MVC 2 and then integrate StructureMap, <a href="http://code.google.com/p/moq/" target="_blank">Moq</a>, <a href="http://www.mbunit.com/" target="_blank">MbUnit</a>, and suite of Unit Tests.</p>