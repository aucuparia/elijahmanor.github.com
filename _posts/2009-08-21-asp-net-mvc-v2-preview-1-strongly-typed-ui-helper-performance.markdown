---
layout: post
title: ASP.NET MVC V2 Preview 1 Strongly Typed UI Helper Performance
date: '2009-08-21 10:02:00'
---

<p>I am sure many of you ASP.NET MVC enthusiasts have either examined, downloaded, or started to play around with the <a href="http://www.microsoft.com/downloadS/details.aspx?familyid=D34F9EAA-FCBE-4E20-B2FD-A9A03DE7D6DD&displaylang=en">ASP.NET MVC V2 Preview 1</a> release.</p>  <p>One of the many new features is the concept of Strongly Typed UI Helpers such as Html.DisplayFor() & Html.EditorFor() which take a Lambda Expression as their argument. This is a great new feature because we can now get compile time checking of our arguments and it provides the ability to easily refactor changes across our project. The old version of the Html Helpers were littered with Magic Strings that were susceptible to error and painfully resistant to change. </p>  <p>I was talking to a co-worker at <a href="http://www.sommetgroup.com/">Sommet Group</a>, <a href="http://twitter.com/A_Robson">Alex Robson</a>, about the new Strongly Typed UI Helpers and he immediately became curious as to whether the helpers use Lambda Compiles to obtain the Model’s value. I checked the <a href="http://aspnet.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=30886">source code</a> of the ASP.NET MVC V2 Preview 1 release and found the following code snippet from TemplateHelpers.cs…</p>  <pre>internal static void TemplateFor<TModel, TValue>(this HtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string templateName, string htmlFieldId, DataBoundControlMode mode) where TModel : class {<br>   object modelValue = null;<br>   try {<br>      modelValue = expression.Compile()(html.ViewData.Model);<br>   }<br>   catch (NullReferenceException) { }  // Okay if it throws a null ref exception, we can infer types without the actual data<br>   //Etc...<br>}</pre> <p>The reason for the concern is that he read a recent <a href="http://blog.whiletrue.com/2009/04/aspnet-mvc-performance/">slide deck</a> by <a href="mailto://rudib@whiletrue.com">Rudi Benkovic</a> reviewing several performance issues of which Lambda Compiles were a hot topic.</p> <h4>The Experiment</h4> <p>With Alex’s experience developing the Open Source project <a href="http://www.codeplex.com/nvigorate">Nvigorate</a>, he has had a lot of experience working with Lamdas, Reflection, and the like. So, he started on a mission to compare various dynamic access methods and to compare their performance. The following graph provides a high level summary of Alex's findings. You can also read his <a href="http://sharplearningcurve.com/blog/post/2009/08/19/Dynamic-Access-Method-Performance-Comparison.aspx">detailed post</a> from his blog and <a href="http://sharplearningcurve.com/blog/files/accessorperformance.zip">download</a> his sample code.  </p> <p><a href="http://elijahmanor.com/content/binary/WindowsLiveWriter/ASP.NETMVCV2Preview1Performance_BF7B/DynamicAccessMethodPerformance_2.png"><img title="DynamicAccessMethodPerformance" border="0" alt="DynamicAccessMethodPerformance" src="http://elijahmanor.com/content/binary/WindowsLiveWriter/ASP.NETMVCV2Preview1Performance_BF7B/DynamicAccessMethodPerformance_thumb.png" width="621" height="462"></a> </p> <p>As you can see from the graph above, the Lambda Compile is by far the least efficient way to obtain the model’s value when compared with Dynamic Methods, Type Descriptor, and Reflection. The worst part is that the Lambda Compile and Dynamic Method approaches both scaled poorly when the number of test cases increased. </p> <h4>Why Should I Care?</h4> <p>You might be thinking, “Who would actually use 1,000 or even 10,000 instances of the Html.EditorFor() anyway? Why does this really even matter?”. </p> <p>The answer is that we shouldn’t just be concerned about the current page request, but also with the overall scalability of our website as the number of concurrent page requests increase.</p> <h4>What Now?</h4> <p>The good news is that the API for the Strongly Typed UI Helpers don’t need to change in order to accommodate these speed performances. All of Alex’s tests start with a Lambda Expression…</p> <pre>public static void Reflect<TModel, TProperty>(Expression<Func<TModel, TProperty>> expression, TModel instance)<br>{<br>    var val = typeof(TModel).GetProperty(GetMemberFromExpression(expression)).GetValue(instance, new object[] {});<br>    Debug.Assert(val.Equals("Dude"));<br>}<br><br>public static void TypeDescriptorCall<TModel, TProperty>(Expression<Func<TModel, TProperty>> expression, TModel instance)<br>{<br>    var properties = TypeDescriptor.GetProperties(typeof(TModel));<br>    var property = properties.Find(GetMemberFromExpression(expression), false);<br>    TProperty val = (TProperty)property.GetValue(instance);<br>    Debug.Assert(val.Equals("Dude"));<br>}<br><br>public static void DynamicMethodCall<TModel, TProperty>(Expression<Func<TModel, TProperty>> expression, TModel instance)<br>{<br>    var delegateCall = DynamicMethodFactory.CreateGetter(typeof(TModel).GetProperty(GetMemberFromExpression(expression)));<br>    var val = delegateCall(instance);<br>    Debug.Assert(val.Equals("Dude"));<br>}<br><br>public static void LambdaCompile<TModel, TProperty>(Expression<Func<TModel, TProperty>> expression, TModel instance)<br>{<br>    var val = expression.Compile()(instance);<br>    Debug.Assert(val.Equals("Dude"));<br>}</pre> <h4>Summary</h4> <p>Based on some initial work done by <a href="mailto://rudib@whiletrue.com">Rudi Benkovic</a> as seen in his <a href="http://blog.whiletrue.com/2009/04/aspnet-mvc-performance/">slide deck</a>, it came to our attention that Lamda Compiles can be very slow and actually affect website scaling when using ASP.NET MVC.</p> <p>Thanks to <a href="http://twitter.com/A_Robson">Alex Robson</a>, he compared 4 different dynamic access methods and compared their performance. His findings showed that using a Lamda Compile was the slowest of the 4 approaches tested when obtaining a Model’s value from a Lambda Expression. In contrast, Reflection was by far the fastest approach to consistently retrieve a Model’s value.</p> <p>I hope the ASP.NET MVC team will take note of these findings and consider using Reflection instead of Compiling the Lamda inside of their next preview release. </p>